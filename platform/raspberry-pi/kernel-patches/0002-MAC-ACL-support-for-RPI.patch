From 7882aa931dec93a21c5a8853f4ef552bbda7b2d5 Mon Sep 17 00:00:00 2001
From: Rakhil P E <Rakhil_PuthiyaveettilEdachena@comcast.com>
Date: Thu, 6 Feb 2025 12:33:21 +0530
Subject: [PATCH] Added MAC ACL support for RPI by modifying kernel and driver
 code

- Due to lack of access to RPI firmware and its lack of support for MAC mode, the implementation is done at the kernel level.
- Modified relevant kernel modules and driver files to handle MAC ACL functionality.

Signed-off-by: Rakhil P E <rakhilpe001@gmail.com>
---
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 76 +++++++++++++++++++
 .../broadcom/brcm80211/brcmfmac/cfg80211.h    | 25 ++++++
 2 files changed, 101 insertions(+)

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index e19c14ba3..171dd236e 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -5930,6 +5930,48 @@ static int brcmf_cfg80211_tdls_oper(struct wiphy *wiphy,
 	return ret;
 }
 
+static int
+brcmf_cfg80211_set_mac_acl(struct wiphy *wiphy, struct net_device *ndev,
+                           const struct cfg80211_acl_data *acl)
+{
+    struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+    int i;
+    int macnum = 0;
+    int macmode = MACLIST_MODE_DISABLED;
+
+    /* if acl == NULL, macmode is still disabled.. */
+    if (!acl) {
+        brcmf_err("Null MAC ACL\n");
+        goto exit;
+    }
+
+    macnum = acl->n_acl_entries;
+    if (macnum < 0 || macnum > MAX_NUM_MAC_FILT) {
+        brcmf_err("invalid number of MAC address entries %d\n", macnum);
+        goto exit;
+    }
+
+    /* get the MAC filter mode */
+    if (acl && acl->acl_policy == NL80211_ACL_POLICY_DENY_UNLESS_LISTED) {
+        macmode = MACLIST_MODE_ALLOW;
+    } else if (acl && acl->acl_policy == NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&
+        acl->n_acl_entries) {
+        macmode = MACLIST_MODE_DENY;
+    }
+
+    cfg->mac_acl.acl_count = acl->n_acl_entries;
+    for (i = 0; i < acl->n_acl_entries; i++) {
+        brcmf_dbg(TRACE, "ACL-MAC : %pM\n", acl->mac_addrs[i].addr);
+        memcpy(cfg->mac_acl.acl_list[i], acl->mac_addrs[i].addr, ETH_ALEN);
+    }
+
+exit:
+    cfg->mac_acl.acl_mode = macmode;
+    brcmf_dbg(TRACE, "Updated ACL Data: mode=%d, count=%d\n", cfg->mac_acl.acl_mode,
+            cfg->mac_acl.acl_count);
+    return 0;
+}
+
 static int
 brcmf_cfg80211_update_conn_params(struct wiphy *wiphy,
 				  struct net_device *ndev,
@@ -6091,6 +6133,7 @@ static struct cfg80211_ops brcmf_cfg80211_ops = {
 	.crit_proto_start = brcmf_cfg80211_crit_proto_start,
 	.crit_proto_stop = brcmf_cfg80211_crit_proto_stop,
 	.tdls_oper = brcmf_cfg80211_tdls_oper,
+	.set_mac_acl = brcmf_cfg80211_set_mac_acl,
 	.update_connect_params = brcmf_cfg80211_update_conn_params,
 	.set_pmk = brcmf_cfg80211_set_pmk,
 	.del_pmk = brcmf_cfg80211_del_pmk,
@@ -6583,6 +6626,30 @@ brcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,
 	return 0;
 }
 
+static bool brcmf_check_acl_cfg(struct brcmf_cfg80211_info *cfg, const u8 *mac_addr) {
+    int i;
+
+    if (cfg->mac_acl.acl_mode == MACLIST_MODE_DISABLED) {
+        return true;
+    }
+
+    for (i = 0; i < cfg->mac_acl.acl_count; i++) {
+        if (memcmp(cfg->mac_acl.acl_list[i], mac_addr, ETH_ALEN) == 0) {
+            if (cfg->mac_acl.acl_mode == MACLIST_MODE_ALLOW) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    if (cfg->mac_acl.acl_mode == MACLIST_MODE_ALLOW) {
+        return false;
+    } else {
+        return true;
+    }
+}
+
 static s32
 brcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,
 			       struct net_device *ndev,
@@ -6603,6 +6670,13 @@ brcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,
 		return 0;
 	}
 
+	if ((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) {
+		if (!brcmf_check_acl_cfg(cfg, e->addr)) {
+			brcmf_err("Connection denied for MAC: %pM\n", e->addr);
+			return 0;
+		}
+	}
+
 	if (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&
 	    (reason == BRCMF_E_STATUS_SUCCESS)) {
 		if (!data) {
@@ -8575,6 +8649,8 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	 */
 	drvr->config = cfg;
 
+	wiphy->max_acl_mac_addrs = MAX_NUM_MAC_FILT;
+
 	err = brcmf_setup_wiphy(wiphy, ifp);
 	if (err < 0)
 		goto priv_out;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
index f6573da57..a37afbb32 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
@@ -92,6 +92,16 @@
 
 #define BRCMF_VIF_EVENT_TIMEOUT		msecs_to_jiffies(1500)
 
+/* hostap mac mode */
+#define MACLIST_MODE_DISABLED   0
+#define MACLIST_MODE_DENY       1
+#define MACLIST_MODE_ALLOW      2
+
+/* max number of mac filter list
+ * restrict max number to 10 as maximum cmd string size is 255
+ */
+#define MAX_NUM_MAC_FILT        10
+
 /**
  * enum brcmf_scan_status - scan engine status
  *
@@ -322,6 +332,19 @@ struct brcmf_cfg80211_wowl {
 	bool nd_enabled;
 };
 
+/**
+ * struct brcmf_cfg80211_acl - acl related information.
+ *
+ * @acl_list: list of mac addresses
+ * @acl_count: current number of mac addresses
+ * @acl_mode: acl policy mode
+ */
+struct brcmf_cfg80211_acl {
+    u8 acl_list[MAX_NUM_MAC_FILT][ETH_ALEN];
+    int acl_count;
+    int acl_mode;
+};
+
 /**
  * struct brcmf_cfg80211_info - dongle private data of cfg80211 interface
  *
@@ -356,6 +379,7 @@ struct brcmf_cfg80211_wowl {
  * @vif_event: vif event signalling.
  * @wowl: wowl related information.
  * @pno: information of pno module.
+ * @mac_acl: acl related information
  */
 struct brcmf_cfg80211_info {
 	struct wiphy *wiphy;
@@ -389,6 +413,7 @@ struct brcmf_cfg80211_info {
 	struct brcmf_cfg80211_wowl wowl;
 	struct brcmf_pno_info *pno;
 	u8 ac_priority[MAX_8021D_PRIO];
+	struct brcmf_cfg80211_acl mac_acl;
 };
 
 /**
-- 
2.25.1

